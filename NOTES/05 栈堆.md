### 堆栈&深浅拷贝

#### **栈stack**

> 存储基本数据，变量名，稳定，不可修改，空间较小
>
> 遵循**后进先出**的原则 

- 存储基础数据类型
- 按值访问
- 存储的值大小固定
- 由系统自动分配内存空间
- 空间小，运行效率高
- 先进后出，后进先出
- 栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。
- 微任务和宏任务

1. 所有同步任务都在主线程上执行，形成一个执行栈
2. 主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就**在任务队列之中放置一个事件**。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行
4. 主线程从任务队列中读取事件，这个过程是循环不断的

```js
console.log(1);
console.log(2);
setTimeout(function(){
    console.log(3);
})
setTimeout(function(){
    console.log(4);
})
console.log(5);

```

结果为1 2 5 3 4，首先执行了栈里的代码，1 2 5。 前面说到的**settimeout**会被放在队列里，当栈执行完了之后，从队列里添加到栈里执行（此时是依次执行），得到 3 4 

```js
console.log(1);
console.log(2);

setTimeout(function(){
    console.log(3);
    setTimeout(function(){
        console.log(6);
    })
},400)
setTimeout(function(){
    console.log(4);
    setTimeout(function(){
        console.log(7);
    })
},100)
console.log(5)
```

 如上：这里的顺序是1 2 5 4 7 3 6。也就是只要两个set时间不一样的时候 ，就set时间短的先走完，包括set里面的回调函数，再走set时间慢的。（因为只有当时间到了的时候，才会把set放到队列里面去） 



**结论**： 永远都是**栈里的代码先行执行**，再从队列中依次读事件，加入栈中执行 

​	stack（栈）里面都走完之后，就会依次读取任务队列,将队列中的事件放到执行栈中依次执行，这个时候栈中又出现了事件，这个事件又去调用了WebAPIs里的异步方法，那这些异步方法会在再被调用的时候放在队列里，然后这个主线程（也就是stack）执行完后又将从任务队列中依次读取事件，这个过程是循环不断的。





#### 堆heap

> 存储的数据，可被修改，空间大
>
> 遵循**先进先出**的原则

- 存储引用数据类型

- 按引用访问

- 存储的值大小不定，可动态调整

- 主要用来存放对象

- 空间大，但是运行效率相对较低

- 无序存储，可根据引用直接获取

  与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript**不允许直接访问堆内存中的位置**，因此我们不能直接操作对象的堆内存空间。看一下下面的图，加深理解。 

![wechatimg104](https://user-gold-cdn.xitu.io/2018/6/13/163f6b03478ae38a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

```js
var a1 = 0;   // 栈 
var a2 = 'this is string'; // 栈
var a3 = null; // 栈

var b = { m: 20 }; // 变量b存在于栈中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中
```

 因此当我们要访问堆内存中的**引用数据类型**时，实际上我们首先是**从栈中获取了该对象的地址引用（或者地址指针）**，然后再从堆内存中取得我们需要的数据。 


基本数据(值传递的数据)：字符，数值，布尔，undefined

拷贝时，拷贝的是值，值就是地址，地址就是值

复杂数据(引用传递的数据)：对象->数组，函数，...

拷贝时，拷贝的是地址，地址就是地址，值就是指

拷贝地址时，叫浅拷贝

拷贝值时，叫深拷贝



#### 浅拷贝

>  浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 

```js
 var obj1 = {
    'name' : 'zhangsan',
    'age' :  '18',
    'language' : [1,[2,3],[4,5]],
};
var obj2 = obj1;
obj2.name = "lisi";
obj2.language[1] = ["二","三"];
console.log('obj1',obj1)
console.log('obj2',obj2)
```

 ![img](https://user-gold-cdn.xitu.io/2018/12/23/167da6385719783f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 深拷贝

>  深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 



内置独享